2016.11.30本次修改Render RenderHitachi Player，目的有：1. 把player装进DmcData，去掉DmcData里面的uuid，因为它和map的key重复了2. 去掉RenderHitachi里面的player, url, mime数组，它们可以从map里面获取3. 去掉重复的presenter和isNormalMode及moderator相关信息，换成presenterUUId_和moderator class，   uuid的非空就是presenter mode， moderator class处理moderator的功能4. 使用string替换char*，避免频繁的分配释放内存，和内存泄露，替换一些字符串的解析到std::string，   尽量不预先分配想象中固定大小的内存4. 改写player.cpp，只留有用的信息，dmr的player在hitachi项目上只处理image和audio的thumbnail。   保存的state也是有用的信息5. 同步所有类型，枚举除了在dmr和stack，dmr和app接口转型外都一致，替换表示二值的int到bool6. shared_ptr使用，#define 替换为 const static，comment add， code style7. remove no use codeuseful:1.image使用的是OnSetURIRequest, 播放没有直接回调给app，而是下载后才回调给app：    if(player)    {        result = player->play(); // 通过下载回调，注意同时处理image和audio的thumbnail        if(player->getType() != TYPE_IMAGE && mPlayerCallback && mPlayerCallback->OnPlayRequest)        {            result = (ADLNA_DMR_PlayerHandlerResult) mPlayerCallback->OnPlayRequest(const_cast<char*>(uuid.c_str()), iDisplayID, const_cast<char*>(url.c_str()), mUserData);        }        YELLOW_PRINTF("RenderHitachi::OnPlayRequest out result:%d", result);    }        image下载后回调OnPlayRequest，audio的thumbnail的路径时audio的路径后面加上"?class=audio"，它下载完不是通过OnPlayRequest，    而是通过OnDownloadResult通知app的    2.player flow:    handle_REQUEST_PUSH    OnGetRendererStateRequest    OnStopRequest    OnSetURIRequest    OnGetRendererStateRequest    OnPlayRequest    OnGetRendererStateRequest    OnStopRequest    OnGetRendererStateRequest        OnGetRendererStateRequest要保证返回正确的值，不然stack会报705给link+，在seturirequest时state要是stopped?    这个值player可以给，app可以通过回调给，或者render自己保存给？    通过app会有滞后，它应该是在imageplayer处理后才设置的状态。这时就会报705的issue。    这个逻辑和之前应该一样，不过把state由renderhitachi保存，改为player自己保存。    3.handle_DMC_NOTIFY需要返回正确值，不然stack报501(action fail)给link+，link+会处理它的4.dmr一起来，link+们检测到dmr就发ARC_DMC_QUIT。  2016/12/1 版本link+会不停的发ARC_GET_DMR_NAME(5s 一次),不合理，暂时也用不到  5.OnXArcCommandRequest的返回值不是判断命令是否成功，是判断result是否能分配内存，命令是否成功是result里面  的。这个命令的返回值不成功stack不给link+ result。6.enum define struct should separate with function, when provided to custom, for good using by dmr/*think twice ignore sometimes, to easy link+ work7.dont ignore command, all will return feedback to link+*/8.some cmd dont send response to link+, need more care9.moderator不显示请检查setmoderatoroutputon是否成功 1.audio 单独播放走seturirequest, slideshow的background music走backgroud music2.it seems presenterMode and screenMode(i.e. displaymode) can set BOTH by OnSetURIRequest   and SET_DISPLAY_MODE and SET_PRESENTER, unreasonable by i think  3.set presenter mode极其混乱，没有任何逻辑4.camerapreview mirror projecting 的presenter都是通过命令和url来传递的，没有通过  SET_PRESENTER。  他们的screenIndex都是通过命令和url来传递的，没有通过SET_SCREEN_INDEX  5.ARC_DMC_OCCUPIED命令格式：  ARC_DMC_OCCUPIED + 被occupied的linkUUID + 去occupied的linkUUID(moderatorUUID, null, clear)  6. todo(abcd need link+ cowork):         a, need start stop pause resume startdata stopdata ACK to fulfill feature, for good design         b, need authentication when link+ first connect         c, need autio ts, sys ts, video ts to sync play         d, dmr cmd should use key-value         e, remove all other log, leave only glog         f, further refine7. Audio data should direct to play, not using getaudiodata8. 播放流程： request push -> stop -> seturi -> play   seturi时stack 会通过OnGetRendererStateRequest获取当前状态， 如果切换播放时，play处于播放状态就出错了，必须   处于stop状态。   同时如果dmr端或者link+端主动发onstoprequest 给icsapp，icsapp就不会调用 DMR_Player_Stop_Notify，这个接口直接发ARC_DMC_OCCUPIED,   link+通过这个命令恢复停止投影状态。  9. 